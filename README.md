# readme

## 任务说明

编写一个钱币定位系统，其不仅能够检测出输入图像中各个钱币的边缘，同时，还能给出各个钱币的圆心坐标与半径。

## 设计概要和算法流程

程序中主要使用了canny算法还有Hough算法完成了给定图像中硬币的边缘、半径及圆心的检测。其中，本人使用了numpy库自主实现了Canny算法，完成了硬币的边缘检测；调用了opencv中的HoughCircle函数，实现了硬币的圆心坐标和半径的检测。

### 主要流程：

1. 从文件中读取图像，并转化成灰度图；

2. Canny算法主要完成了图像高斯核平滑、计算梯度强度、应用非极大值抑制、应用双阈值抑制且孤立弱边缘，完成了初步的边缘检测；

3. Hough算法中调用了cv2.HoughCircles函数完成了对硬币边缘的检测及分析半径和圆心坐标；

4. 最后，输出圆心坐标及半径，并在原图像中标明硬币边缘及圆心。

## 函数功能分析

以下为Canny算法中自主实现的函数：

### 1. 获取图像

```python
def get_img(path)
# 完成对输入图像的读取及初始化
# 1. 从文件中读取输入图像
# 2. 使用np.copy读入numpy数组
# 3. 使用np.mean方法对rgb通道求取均值，获得灰度图
# 4. 返回灰度图及原始图像（原始图像在Hough算法中需要用到）
```

### 2. 获取高斯核

```python
def get_gaussian_kernel(k, sigma)
# 用给定的k值和sigma值初始化高斯滤波器
# 1. 使用np.zeros方法初始化滤波器
# 2. 使用公式1，对滤波器进行初始化
# 3. 归一化并返回
```

$$
公式1\\
H_{ij}=\frac{1}{2\pi\sigma^2}exp(-\frac{(i-k)^2+(j-k)^2}{2\sigma^2})\\
(0\leq i,j\leq 2k)
$$

在滤波器的参数选取试，本人选用了滤波器窗宽参数k=1（实际滤波器的宽高为3）和sigma=1.4作为高斯核的标准差。sigma值使用了根号2这个主流的标准差值。对于k值，本人曾尝试过k=1, 3, 5，当k=3的时候canny的边缘检测结果最好，除了硬币的区域外空白的地方无关像素最少，但是最终硬币的边缘检测效果略有偏差；k=5的时候边缘检测的偏差更大了，最终选用了k=1，在这个取值下，最终的硬币边缘检测效果最好。

### 3. 二维卷积

```python
def conv2d(img, kernel, pad=(0, 0), stride=1)
# 二维卷积函数，在高斯核平滑、梯度计算时用到
"""
自主实现了二维卷积函数，使用了im2col方法，将卷积图像中的像素按照卷积核的框大小逐个展开成列，并将卷积核展开成行。最后将两者直接做矩阵乘法，并调整好维度，得到最终的卷积结果。
"""
```

### 4. 梯度计算

```python
def get_gradient_pic(img)
# 基于sober算子的边缘提取，以下为sober算子在x、y方向的滤波器：
#      x          y
#   -1 0 1      1  2  1
#   -2 0 2      0  0  0
#   -1 0 1     -1 -2 -1
#
# 利用sober_x, sober_y作为卷积核分别卷积输入图像，得到x、y方向的梯度分布图
```

### 5. 非极大值抑制

```python
def NMS(Gx, Gy)
"""
传入参数：原图像在x、y方向的梯度矩阵
"""
# 1. 将x、y方向的梯度矩阵做平方运算
# 2. 将Gx中为0的像素值更改为10的-5次方，防止分母为0
# 3. 获取梯度方向（角度）矩阵，并将方向全部设置为正角度：
temp = np.arctan(Gy, Gx) / np.pi * 180.
temp[temp < -22.5] += 180.
# 4. 以22.5度为界限，将所有方向角度更改为0度、45度、90度、135度；
# 5. 对梯度方向矩阵中所有元素进行分析，首先计算出坐标偏移量（对图像边缘像素油特殊处理），再对当前坐标对应的梯度值进行分析，如果当前像素相对于梯度正负方向相邻的梯度值不是最大的，则该点将被抑制（设置为0）
```

### 6. 双阈值检测及孤立弱边缘

```python
def DTD(src, HT=100, LT=10)
"""
输入：HT：高阈值，LT：低阈值，src：经过NMS处理的边缘图像
"""
# 1. 将大于高阈值的像素设置为255（纯白强边缘），低于低阈值的像素值设置为0（抑制像素）
# 2. 使用8领域法，对图像中各个像素点做比较。具体做法：用3*3的、除了中心元素为0其余元素均为1的矩阵，对图像中像素值介于高低阈值间的像素做普通乘法。乘法的结果为3*3的矩阵，除了中间的元素为0，剩余8个元素就是观察像素点A周围的8个像素，再对其取最大值，若像素值大于高阈值则将观察像素点A设置为255作为强边缘的延续；否则设置为0，作为抑制边缘。
```

在实际测试的时候，本人选取了高阈值=50，低阈值=5作为参数，而非使用初始化值。在这组参数下，右上方的硬币边缘能够准确检测出来。当阈值高于10的时候，右上方的硬币边缘将会有一定程度的缺失。

### 7. Hough算法检测边缘图中的圆形

```python
hough = cv2.HoughCircles(np.uint8(G), cv2.HOUGH_GRADIENT, dp=1, minDist=400, param1=100, param2=40, minRadius=50, maxRadius=200)

# 调用cv2的HoughCircles函数，实现对图像中圆形的检测
# 返回值：所有检测到的圆形的圆心坐标、半径
# 参数：
# 1. np.uint8(G)：检测图像，必须为uint8格式
# 2. cv2.HOUGH_GRADIENT：检测方法
# 3. dp=1：检测内侧圆心的累加器图像的分辨率于输入图像之比的倒数，为1则代表累加器和输入图像具有相同的分辨率
# 4. minDist=400：圆心间最小间距
# 5. param1=100：method设置的检测方法的对应的参数（默认100），对当前唯一的方法霍夫梯度法cv2.HOUGH_GRADIENT，它表示传递给canny边缘检测算子的高阈值，而低阈值为高阈值的一半
# 6. param2=40：method设置的检测方法的对应的参数，对当前唯一的方法霍夫梯度法cv2.HOUGH_GRADIENT，它表示在检测阶段圆心的累加器阈值，它越小，就越可以检测到更多根本不存在的圆，而它越大的话，能通过检测的圆就更加接近完美的圆形了
"""param2的调试过程：取值从默认值100逐渐降低到40（步长为10），发现在40的时候能正好检测到所有的硬币"""
# 7. minRadius=50, maxRadius=200：最小和最大半径
```

最终，输出六个硬币的圆心坐标及半径。

